
>nextValue()

>nextValue()

>setValue(V[]value)

>enableProbability(booleanenable)

>classify(Stringtext)
predict
CollectionUtility.max

>classify(Documentdocument)
predict
CollectionUtility.max

>train(StringfolderPath,StringcharsetName)
dataSet.load
train

>train(Map<String,String[]>trainingDataSet)
logger.start
trainingDataSet.size
trainingDataSet.entrySet
entry.getKey
logger.out
entry.getValue
dataSet.add
logger.out
MathUtility.percentage
logger.finish
train

>train(StringfolderPath)
train

>predict(Documentdocument)
getModel
categorize
scoreMap.put

>label(Documentdocument)
getModel
categorize

>nextWords(intn,Stringmsg)
nextWord

>nextWord()
scanner.next
word.length
word.equals

>getTargetVector()

>execute()
vectorsReader.readVectorFile
vectorsReader.getNumWords
vectorsReader.getSize
getTargetVector
vectorsReader.getMatrixElement
vectorsReader.getWord
scanner.close

>setTokenizer(ITokenizertokenizer)

>convert(Stringcategory,Stringtext)
tokenizer.segment

>getTokenizer()

>getCatalog()

>getLexicon()

>load(StringfolderPath,StringcharsetName)
load

>load(StringfolderPath)
load

>isTestingDataSet()

>load(StringfolderPath,StringcharsetName,doublepercentage)
root.exists
String.format
root.getAbsolutePath
root.isDirectory
String.format
root.getAbsolutePath
root.listFiles
logger.start
folder.isFile
folder.listFiles
folder.getName
logger.out
Math.ceil
add
folder.getName
TextProcessUtility.readTxt
logger.out
MathUtility.percentage
logger.out
logger.finish
getCatalog
.size
size

>load(StringfolderPath,doublerate)

>add(Map<String,String[]>testingDataSet)
testingDataSet.entrySet
entry.getValue
add
entry.getKey
HanLP.newSegment
.enablePartOfSpeechTagging

>parse(Stringsentence)
parse
segment.seg
sentence.toCharArray
deprelTranslater.get

>getSegment()

>setSegment(Segmentsegment)

>getDeprelTranslator()

>setDeprelTranslator(Map<String,String>deprelTranslator)

>setDeprelTranslater(StringdeprelTranslatorPath)
GlobalObjectPool.get
iterator.hasNext
iterator.next
.split
deprelTranslater.put
deprelTranslater.size
GlobalObjectPool.put

>enableDeprelTranslator(booleanenable)

>compareTo(AbstractInexactActiono)
.compareTo

>equals(Objectobj)

>name()

>rel()

>localUsage()

>paramDesc(Stringparam,Stringdesc)

>usage()
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
localUsage

>argPos(Stringparam,String[]args)
argPos

>argPos(Stringparam,String[]args,booleancheckArgNum)
param.equals
String.format

>setConfig(String[]args,Configconfig)
argPos
config.setLayer1Size
Integer.parseInt
argPos
config.setOutputFile
argPos
config.setUseContinuousBagOfWords
Integer.parseInt
config.useContinuousBagOfWords
config.setAlpha
argPos
config.setAlpha
Float.parseFloat
argPos
config.setWindow
Integer.parseInt
argPos
config.setSample
Float.parseFloat
argPos
config.setUseHierarchicalSoftmax
Integer.parseInt
argPos
config.setNegative
Integer.parseInt
argPos
config.setNumThreads
Integer.parseInt
argPos
config.setIter
Integer.parseInt
argPos
config.setMinCount
Integer.parseInt

>vector(Kkey)
storage.get

>similarity(Kwhat,Kwith)
storage.get
storage.get
vectorWhat.cosineForUnitVector

>nearest(Kkey,intsize)
storage.get
Collections.emptyList
nearest

>nearest(Kkey,Vectorvector,intsize)

>compare(Map.Entry<K,Float>o1,Map.Entry<K,Float>o2)
o1.getValue
.compareTo
o2.getValue
storage.entrySet
entry.getKey
.equals
maxHeap.add
entry.getKey
entry.getValue
.cosineForUnitVector
maxHeap.toList

>nearest(Vectorvector,intsize)

>compare(Map.Entry<K,Float>o1,Map.Entry<K,Float>o2)
o1.getValue
.compareTo
o2.getValue
storage.entrySet
maxHeap.add
entry.getKey
entry.getValue
.cosineForUnitVector
maxHeap.toList

>nearest(Vectorvector)
nearest

>nearest(Kkey)
nearest

>queryNearest(Stringquery,intsize)
query.length
Collections.emptyList
nearest
query
Collections.emptyList

>query(Stringquery)

>size()
storage.size

>dimension()
storage.isEmpty
storage.values
.iterator
.next
.size

>remove(Kkey)
storage.remove

>make_shift()

>make_left_arc(finalintrel)

>make_right_arc(finalintrel)

>is_shift(finalActionact)
act.name

>is_left_arc(finalActionact,int[]deprel)
act.name
act.rel

>is_right_arc(finalActionact,int[]deprel)
act.name
act.rel

>get_oracle_actions(List<Integer>heads,List<Integer>deprels,List<Action>actions)
heads.size
actions.clear
heads.get
tree.get
tree.get
get_oracle_actions_travel

>get_oracle_actions_travel(introot,List<Integer>heads,List<Integer>deprels,List<List<Integer>>tree,List<Action>actions)
tree.get
children.size
children.get
get_oracle_actions_travel
children.get
actions.add
ActionFactory.make_shift
children.size
children.get
get_oracle_actions_travel
actions.add
ActionFactory.make_right_arc
deprels.get
children.get
actions.add
ActionFactory.make_left_arc
deprels.get

>get_oracle_actions2(Dependencyinstance,List<Action>actions)
get_oracle_actions2

>get_oracle_actions2(List<Integer>heads,List<Integer>deprels,List<Action>actions)
actions.clear
heads.size
output.add
sigma.size
get_oracle_actions_onestep

>get_oracle_actions_onestep(List<Integer>heads,List<Integer>deprels,List<Integer>sigma,int[]beta,List<Integer>output,List<Action>actions)
sigma.size
sigma.get
sigma.size
sigma.size
sigma.get
sigma.size
heads.size
heads.get
output.get
heads.get
actions.add
ActionFactory.make_left_arc
deprels.get
output.set
sigma.remove
sigma.size
sigma.set
sigma.size
heads.get
actions.add
ActionFactory.make_right_arc
deprels.get
output.set
sigma.remove
sigma.size
heads.size
actions.add
ActionFactory.make_shift
sigma.add

>testAdjust()
FolderWalker.open
handle

>handle(Filefile)
IOUtil.readTxt
file.getPath
text.length
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
text.length
bw.write
bw.close
e.printStackTrace

>addW(Stringtext,Stringc)
text.replaceAll
text.replaceAll

>testPlay()
CorpusLoader.walk

>handle(Documentdocument)
document.getComplexSentenceList
word.getLabel
.equals
tfDictionary.add
word.toString
tfDictionary.saveTxtTo

>testAdjustNGram()
iterator.hasNext
iterator.next
line.split
.split
.split
Integer.parseInt
CoreDictionary.get
first.length
second.length
bw.write
bw.newLine
bw.close

>testRemoveLabelD()
lineIterator.hasNext
lineIterator.next
line.split
.split
.equals
nameFollowers.add
DictionaryMaker.load
dictionary.entrySet
entry.getKey
entry.getValue
.getFrequency
key.length
CoreDictionary.get
nameFollowers.contains
attribute.hasNatureStartsWith
entry.getValue
entry.getValue
dictionary.saveTxtTo
build

>parseText(Stringtext)
text.length
getState
text.charAt
storeEmits

>parseText(Stringtext,IHit<V>processor)
text.length
getState
text.charAt
processor.hit

>parseText(char[]text,IHit<V>processor)
getState
processor.hit

>parseText(char[]text,IHitFull<V>processor)
getState
processor.hit

>save(DataOutputStreamout)
out.writeInt
out.writeInt
out.writeInt
out.writeInt
out.writeInt
out.writeInt
out.writeInt
out.writeInt
out.writeInt

>save(ObjectOutputStreamout)
out.writeObject
out.writeObject
out.writeObject
out.writeObject
out.writeObject

>load(ObjectInputStreamin,V[]value)
in.readObject
in.readObject
in.readObject
in.readObject
in.readObject

>load(ByteArraybyteArray,V[]value)
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt

>get(Stringkey)
exactMatchSearch

>set(Stringkey,Vvalue)
exactMatchSearch

>get(intindex)

>hit(intbegin,intend,Vvalue)

>hit(intbegin,intend,Vvalue,intindex)

>toString()
String.format

>getState(intcurrentState,charcharacter)
transitionWithRoot
transitionWithRoot

>storeEmits(intposition,intcurrentState,List<Hit<V>>collectedEmits)
collectedEmits.add

>transition(intcurrent,charc)

>transitionWithRoot(intnodePos,charc)

>build(TreeMap<String,V>map)
newBuilder

>fetch(Stateparent,List<Map.Entry<Integer,State>>siblings)
parent.isAcceptable
parent.getDepth
fakeNode.addEmit
parent.getLargestValueId
siblings.add
parent.getSuccess
.entrySet
siblings.add
entry.getKey
entry.getValue
siblings.size

>exactMatchSearch(Stringkey)
exactMatchSearch

>exactMatchSearch(Stringkey,intpos,intlen,intnodePos)
key.length
key.toCharArray

>exactMatchSearch(char[]keyChars,intpos,intlen,intnodePos)

>add(Stringname,intvalue)
nameValueMap.get
String.format
nameValueMap.put

>toString()
nameValueMap.entrySet
entry.getKey
entry.getValue
String.format

>println()

>size()

>build(TreeMap<String,V>map)
map.values
.toArray
map.keySet
addAllKeyword
buildDoubleArrayTrie
constructFailureStates
loseWeight

>addKeyword(Stringkeyword,intindex)
keyword.toCharArray
currentState.addState
currentState.addEmit
keyword.length

>addAllKeyword(Collection<String>keywordSet)
addKeyword

>constructFailureStates()
.getStates
depthOneState.setFailure
queue.add
constructOutput
queue.isEmpty
queue.remove
currentState.getTransitions
currentState.nextState
queue.add
currentState.failure
traceFailureState.nextState
traceFailureState.failure
traceFailureState.nextState
targetState.setFailure
targetState.addEmit
newFailureState.emit
constructOutput

>constructOutput(StatetargetState)
targetState.emit
emit.size
emit.size
emit.iterator
it.next
targetState.getIndex

>buildDoubleArrayTrie(Set<String>keySet)
keySet.size
resize
root_node.getSuccess
.entrySet
.size
fetch
insert

>resize(intnewSize)

>insert(List<Map.Entry<Integer,State>>siblings)
Math.max
siblings.get
.getKey
resize
resize
siblings.get
.getKey
siblings.get
siblings.size
.getKey
resize
siblings.size
siblings.get
.getKey
siblings.get
siblings.size
.getKey
siblings.get
siblings.size
.getKey
sibling.getKey
sibling.getValue
.getSuccess
.entrySet
.size
fetch
sibling.getValue
sibling.getKey
sibling.getValue
.getLargestValueId
insert
sibling.getKey
sibling.getValue
sibling.getValue
sibling.getKey

>loseWeight()
