
>nextValue()

>nextValue()

>setValue(V[]value)

>enableProbability(booleanenable)

>classify(Stringtext)
predict
CollectionUtility.max

>classify(Documentdocument)
predict
CollectionUtility.max

>train(StringfolderPath,StringcharsetName)
dataSet.load
train

>train(Map<String,String[]>trainingDataSet)
logger.start
trainingDataSet.size
trainingDataSet.entrySet
entry.getKey
logger.out
entry.getValue
dataSet.add
logger.out
MathUtility.percentage
logger.finish
train

>train(StringfolderPath)
train

>predict(Documentdocument)
getModel
categorize
scoreMap.put

>label(Documentdocument)
getModel
categorize

>nextWords(intn,Stringmsg)
nextWord

>nextWord()
scanner.next
word.length
word.equals

>getTargetVector()

>execute()
vectorsReader.readVectorFile
vectorsReader.getNumWords
vectorsReader.getSize
getTargetVector
vectorsReader.getMatrixElement
vectorsReader.getWord
scanner.close

>setTokenizer(ITokenizertokenizer)

>convert(Stringcategory,Stringtext)
tokenizer.segment

>getTokenizer()

>getCatalog()

>getLexicon()

>load(StringfolderPath,StringcharsetName)
load

>load(StringfolderPath)
load

>isTestingDataSet()

>load(StringfolderPath,StringcharsetName,doublepercentage)
root.exists
String.format
root.getAbsolutePath
root.isDirectory
String.format
root.getAbsolutePath
root.listFiles
logger.start
folder.isFile
folder.listFiles
folder.getName
logger.out
Math.ceil
add
folder.getName
TextProcessUtility.readTxt
logger.out
MathUtility.percentage
logger.out
logger.finish
getCatalog
.size
size

>load(StringfolderPath,doublerate)

>add(Map<String,String[]>testingDataSet)
testingDataSet.entrySet
entry.getValue
add
entry.getKey
HanLP.newSegment
.enablePartOfSpeechTagging

>parse(Stringsentence)
parse
segment.seg
sentence.toCharArray
deprelTranslater.get

>getSegment()

>setSegment(Segmentsegment)

>getDeprelTranslator()

>setDeprelTranslator(Map<String,String>deprelTranslator)

>setDeprelTranslater(StringdeprelTranslatorPath)
GlobalObjectPool.get
iterator.hasNext
iterator.next
.split
deprelTranslater.put
deprelTranslater.size
GlobalObjectPool.put

>enableDeprelTranslator(booleanenable)

>compareTo(AbstractInexactActiono)
.compareTo

>equals(Objectobj)

>name()

>rel()

>localUsage()

>paramDesc(Stringparam,Stringdesc)

>usage()
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
paramDesc
localUsage

>argPos(Stringparam,String[]args)
argPos

>argPos(Stringparam,String[]args,booleancheckArgNum)
param.equals
String.format

>setConfig(String[]args,Configconfig)
argPos
config.setLayer1Size
Integer.parseInt
argPos
config.setOutputFile
argPos
config.setUseContinuousBagOfWords
Integer.parseInt
config.useContinuousBagOfWords
config.setAlpha
argPos
config.setAlpha
Float.parseFloat
argPos
config.setWindow
Integer.parseInt
argPos
config.setSample
Float.parseFloat
argPos
config.setUseHierarchicalSoftmax
Integer.parseInt
argPos
config.setNegative
Integer.parseInt
argPos
config.setNumThreads
Integer.parseInt
argPos
config.setIter
Integer.parseInt
argPos
config.setMinCount
Integer.parseInt

>vector(Kkey)
storage.get

>similarity(Kwhat,Kwith)
storage.get
storage.get
vectorWhat.cosineForUnitVector

>nearest(Kkey,intsize)
storage.get
Collections.emptyList
nearest

>nearest(Kkey,Vectorvector,intsize)

>compare(Map.Entry<K,Float>o1,Map.Entry<K,Float>o2)
o1.getValue
.compareTo
o2.getValue
storage.entrySet
entry.getKey
.equals
maxHeap.add
entry.getKey
entry.getValue
.cosineForUnitVector
maxHeap.toList

>nearest(Vectorvector,intsize)

>compare(Map.Entry<K,Float>o1,Map.Entry<K,Float>o2)
o1.getValue
.compareTo
o2.getValue
storage.entrySet
maxHeap.add
entry.getKey
entry.getValue
.cosineForUnitVector
maxHeap.toList

>nearest(Vectorvector)
nearest

>nearest(Kkey)
nearest

>queryNearest(Stringquery,intsize)
query.length
Collections.emptyList
nearest
query
Collections.emptyList

>query(Stringquery)

>size()
storage.size

>dimension()
storage.isEmpty
storage.values
.iterator
.next
.size

>remove(Kkey)
storage.remove

>make_shift()

>make_left_arc(finalintrel)

>make_right_arc(finalintrel)

>is_shift(finalActionact)
act.name

>is_left_arc(finalActionact,int[]deprel)
act.name
act.rel

>is_right_arc(finalActionact,int[]deprel)
act.name
act.rel

>get_oracle_actions(List<Integer>heads,List<Integer>deprels,List<Action>actions)
heads.size
actions.clear
heads.get
tree.get
tree.get
get_oracle_actions_travel

>get_oracle_actions_travel(introot,List<Integer>heads,List<Integer>deprels,List<List<Integer>>tree,List<Action>actions)
tree.get
children.size
children.get
get_oracle_actions_travel
children.get
actions.add
ActionFactory.make_shift
children.size
children.get
get_oracle_actions_travel
actions.add
ActionFactory.make_right_arc
deprels.get
children.get
actions.add
ActionFactory.make_left_arc
deprels.get

>get_oracle_actions2(Dependencyinstance,List<Action>actions)
get_oracle_actions2

>get_oracle_actions2(List<Integer>heads,List<Integer>deprels,List<Action>actions)
actions.clear
heads.size
output.add
sigma.size
get_oracle_actions_onestep

>get_oracle_actions_onestep(List<Integer>heads,List<Integer>deprels,List<Integer>sigma,int[]beta,List<Integer>output,List<Action>actions)
sigma.size
sigma.get
sigma.size
sigma.size
sigma.get
sigma.size
heads.size
heads.get
output.get
heads.get
actions.add
ActionFactory.make_left_arc
deprels.get
output.set
sigma.remove
sigma.size
sigma.set
sigma.size
heads.get
actions.add
ActionFactory.make_right_arc
deprels.get
output.set
sigma.remove
sigma.size
heads.size
actions.add
ActionFactory.make_shift
sigma.add

>testAdjust()
FolderWalker.open
handle

>handle(Filefile)
IOUtil.readTxt
file.getPath
text.length
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
addW
text.length
bw.write
bw.close
e.printStackTrace

>addW(Stringtext,Stringc)
text.replaceAll
text.replaceAll

>testPlay()
CorpusLoader.walk

>handle(Documentdocument)
document.getComplexSentenceList
word.getLabel
.equals
tfDictionary.add
word.toString
tfDictionary.saveTxtTo

>testAdjustNGram()
iterator.hasNext
iterator.next
line.split
.split
.split
Integer.parseInt
CoreDictionary.get
first.length
second.length
bw.write
bw.newLine
bw.close

>testRemoveLabelD()
lineIterator.hasNext
lineIterator.next
line.split
.split
.equals
nameFollowers.add
DictionaryMaker.load
dictionary.entrySet
entry.getKey
entry.getValue
.getFrequency
key.length
CoreDictionary.get
nameFollowers.contains
attribute.hasNatureStartsWith
entry.getValue
entry.getValue
dictionary.saveTxtTo
build

>parseText(Stringtext)
text.length
getState
text.charAt
storeEmits

>parseText(Stringtext,IHit<V>processor)
text.length
getState
text.charAt
processor.hit

>parseText(char[]text,IHit<V>processor)
getState
processor.hit

>parseText(char[]text,IHitFull<V>processor)
getState
processor.hit

>save(DataOutputStreamout)
out.writeInt
out.writeInt
out.writeInt
out.writeInt
out.writeInt
out.writeInt
out.writeInt
out.writeInt
out.writeInt

>save(ObjectOutputStreamout)
out.writeObject
out.writeObject
out.writeObject
out.writeObject
out.writeObject

>load(ObjectInputStreamin,V[]value)
in.readObject
in.readObject
in.readObject
in.readObject
in.readObject

>load(ByteArraybyteArray,V[]value)
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt
byteArray.nextInt

>get(Stringkey)
exactMatchSearch

>set(Stringkey,Vvalue)
exactMatchSearch

>get(intindex)

>hit(intbegin,intend,Vvalue)

>hit(intbegin,intend,Vvalue,intindex)

>toString()
String.format

>getState(intcurrentState,charcharacter)
transitionWithRoot
transitionWithRoot

>storeEmits(intposition,intcurrentState,List<Hit<V>>collectedEmits)
collectedEmits.add

>transition(intcurrent,charc)

>transitionWithRoot(intnodePos,charc)

>build(TreeMap<String,V>map)
newBuilder

>fetch(Stateparent,List<Map.Entry<Integer,State>>siblings)
parent.isAcceptable
parent.getDepth
fakeNode.addEmit
parent.getLargestValueId
siblings.add
parent.getSuccess
.entrySet
siblings.add
entry.getKey
entry.getValue
siblings.size

>exactMatchSearch(Stringkey)
exactMatchSearch

>exactMatchSearch(Stringkey,intpos,intlen,intnodePos)
key.length
key.toCharArray

>exactMatchSearch(char[]keyChars,intpos,intlen,intnodePos)

>add(Stringname,intvalue)
nameValueMap.get
String.format
nameValueMap.put

>toString()
nameValueMap.entrySet
entry.getKey
entry.getValue
String.format

>println()

>size()

>build(TreeMap<String,V>map)
map.values
.toArray
map.keySet
addAllKeyword
buildDoubleArrayTrie
constructFailureStates
loseWeight

>addKeyword(Stringkeyword,intindex)
keyword.toCharArray
currentState.addState
currentState.addEmit
keyword.length

>addAllKeyword(Collection<String>keywordSet)
addKeyword

>constructFailureStates()
.getStates
depthOneState.setFailure
queue.add
constructOutput
queue.isEmpty
queue.remove
currentState.getTransitions
currentState.nextState
queue.add
currentState.failure
traceFailureState.nextState
traceFailureState.failure
traceFailureState.nextState
targetState.setFailure
targetState.addEmit
newFailureState.emit
constructOutput

>constructOutput(StatetargetState)
targetState.emit
emit.size
emit.size
emit.iterator
it.next
targetState.getIndex

>buildDoubleArrayTrie(Set<String>keySet)
keySet.size
resize
root_node.getSuccess
.entrySet
.size
fetch
insert

>resize(intnewSize)

>insert(List<Map.Entry<Integer,State>>siblings)
Math.max
siblings.get
.getKey
resize
resize
siblings.get
.getKey
siblings.get
siblings.size
.getKey
resize
siblings.size
siblings.get
.getKey
siblings.get
siblings.size
.getKey
siblings.get
siblings.size
.getKey
sibling.getKey
sibling.getValue
.getSuccess
.entrySet
.size
fetch
sibling.getValue
sibling.getKey
sibling.getValue
.getLargestValueId
insert
sibling.getKey
sibling.getValue
sibling.getValue
sibling.getKey

>loseWeight()

>segSentence(char[]sentence)
logger.warning
Collections.emptyList
Arrays.fill
trie.parseText

>hit(intbegin,intend,CoreDictionary.Attributevalue)
quickAtomSegment
atomNode.sWord.length
atomNode.sWord.length
atomNode.getNature
termList.add
trie.build
setTrie

>enableCustomDictionary(booleanenable)

>getTrie()

>setTrie(AhoCorasickDoubleArrayTrie<CoreDictionary.Attribute>trie)

>loadDictionary(String...pathArray)
IOUtil.loadDictionary
logger.warning
TextUtility.exceptionToString
map.isEmpty
trie.build

>testAC()
trie.addKeyword
trie.addKeyword
trie.addKeyword
trie.addKeyword
trie.parseText

>testBuild()
map.put
act.build

>hit(intbegin,intend,Stringvalue)

>testDatFromFile()
iterator.hasNext
iterator.next
map.put
trie.build
map.keySet
assertEquals
trie.get

>testDat()
map.put
trie.build
trie.exactMatchSearch

>testTwoStruct()

>testTwoAC()
iterator.hasNext
iterator.next
.split
map.put
trie.addAllKeyword
map.keySet
act.build
map.keySet
trie.parseText
otherSet.add
emit.getKeyword
emit.getEnd
act.parseText
mySet.add
assertEquals

>testSegment()
iterator.hasNext
iterator.next
.split
map.put
trie.addAllKeyword
map.keySet
act.build
IOUtil.readLineList
act.parseText
assertEquals
sentence.substring

>testHasKeyword()
map.put
trie.addAllKeyword
map.keySet
assertTrue
trie.hasKeyword
assertTrue
trie.hasKeyword
assertFalse
trie.hasKeyword

>labelOf(intid)

>build(TreeMap<String,Integer>keyValueMap)
keyValueMap.size
keyValueMap.entrySet
entry.getValue
entry.getKey
trie.build

>idOf(char[]label)
trie.get

>idOf(Stringlabel)
trie.get

>size()
trie.size

>save(DataOutputStreamout)
out.writeInt
TextUtility.writeString

>load(ByteArraybyteArray)
byteArray.nextInt
byteArray.nextString
map.put
trie.build

>parseOrExit(Objecttarget,String[]args)
parse
e.getMessage
Args.usage

>parse(Objecttarget,String[]args)
parse

>parse(Objecttarget,String[]args,booleanfailOnExtraFlags)
arguments.addAll
Arrays.asList
target.getClass
Introspector.getBeanInfo
info.getPropertyDescriptors
processProperty
currentClazz.getSuperclass
currentClazz.getDeclaredFields
processField
argument.startsWith

>processField(Objecttarget,Fieldfield,List<String>arguments)
field.getAnnotation
arguments.iterator
i.hasNext
i.next
argument.prefix
argument.delimiter
arg.startsWith
getName
getAlias
arg.substring
prefix.length
field.getType
arg.equals
arg.equals
i.remove
consumeArgumentValue
setField
addArgument
type.isArray
argument.required
getName
argument.prefix

>addArgument(Classtype,Fieldfield,Objecttarget,Objectvalue,Stringdelimiter)
field.get
getValue
Array.newInstance
type.getComponentType
field.set
type.getName

>addPropertyArgument(Classtype,PropertyDescriptorproperty,Objecttarget,Objectvalue,Stringdelimiter)
property.getReadMethod
.invoke
getValue
Array.newInstance
type.getComponentType
property.getWriteMethod
property.getWriteMethod
type.getName

>processProperty(Objecttarget,PropertyDescriptorproperty,List<String>arguments)
property.getWriteMethod
writeMethod.getAnnotation
arguments.iterator
i.hasNext
i.next
argument.prefix
argument.delimiter
arg.startsWith
getName
getAlias
arg.substring
prefix.length
property.getPropertyType
arg.equals
arg.equals
i.remove
consumeArgumentValue
setProperty
addPropertyArgument
type.isArray
argument.required
getName

>usage(Objecttarget)

>usage(PrintStreamerrStream,Objecttarget)
target.getClass
clazz.getName
clazzName.lastIndexOf
clazzName.substring
errStream.println
currentClazz.getSuperclass
currentClazz.getDeclaredFields
fieldUsage
Introspector.getBeanInfo
info.getPropertyDescriptors
propertyUsage

>fieldUsage(PrintStreamerrStream,Objecttarget,Fieldfield)
field.getAnnotation
getName
getAlias
argument.prefix
argument.delimiter
argument.description
makeAccessible
field.get
field.getType
propertyUsage

>propertyUsage(PrintStreamerrStream,Objecttarget,PropertyDescriptorfield)
field.getWriteMethod
writeMethod.getAnnotation
getName
getAlias
argument.prefix
argument.delimiter
argument.description
field.getReadMethod
readMethod.invoke
field.getPropertyType
propertyUsage

>propertyUsage(PrintStreamerrStream,Stringprefix,Stringname,Stringalias,Class<?>type,Stringdelimiter,Stringdescription,ObjectdefaultValue)
sb.append
sb.append
sb.append
sb.append
sb.append
sb.append
sb.append
sb.append
sb.append
type.isArray
getTypeName
type.getComponentType
sb.append
sb.append
sb.append
sb.append
getTypeName
sb.append
sb.append
sb.append
sb.append
type.isArray
Array.getLength
list.add
Array.get
sb.append
sb.append
sb.append
errStream.println

>getTypeName(Class<?>type)
type.getName
typeName.lastIndexOf
typeName.substring

>getName(Argumentargument,PropertyDescriptorproperty)
argument.value
name.equals
property.getName

>consumeArgumentValue(Stringname,Class<?>type,Argumentargument,Iterator<String>i)
i.hasNext
i.next
i.remove
argument.prefix

>setProperty(Class<?>type,PropertyDescriptorproperty,Objecttarget,Objectvalue,Stringdelimiter)
getValue
property.getWriteMethod
property.getWriteMethod
type.getName

>getAlias(Argumentargument)
argument.alias
alias.equals

>getName(Argumentargument,Fieldfield)
argument.value
name.equals
field.getName

>setField(Class<?>type,Fieldfield,Objecttarget,Objectvalue,Stringdelimiter)
makeAccessible
getValue
field.set
type.getName

>getValue(Class<?>type,Objectvalue,Stringdelimiter)
type.isArray
string.split
type.getComponentType
Array.newInstance
createValue
createValue

>createValue(Class<?>type,StringvalueAsString)
valueCreator.createValue
String.format
type.toString

>makeAccessible(AccessibleObjectao)
Modifier.isPublic
member.getModifiers
ao.setAccessible

>createValue(Class<?>type,Stringvalue)

>byStaticMethodInvocation(finalClass<?>compatibleType,finalStringmethodName)

>createValue(Class<?>type,Stringvalue)
compatibleType.isAssignableFrom
type.getMethod
m.invoke
String.format
type.toString

>createValue(Class<?>type,Stringvalue)
type.getDeclaredConstructor
init.newInstance
type.getName

>createValue(Classtype,Stringvalue)
.isAssignableFrom
Enum.valueOf
Arrays.asList

>registerValueCreator(ValueCreatorvc)
valueCreators.add

>resetValueCreators()
valueCreators.clear
valueCreators.addAll

>compare(Long[]arrayA,Long[]arrayB)
Math.min
c1.equals
c1.compareTo

>computeMinimumDistance(TreeSet<Long>setA,TreeSet<Long>setB)
setA.toArray
setB.toArray
computeMinimumDistance

>computeMinimumDistance(Long[]arrayA,Long[]arrayB)
Math.abs
Math.abs
Math.abs

>computeAverageDistance(Long[]arrayA,Long[]arrayB)
Math.abs
